#!/bin/bash

PRERELEASE_TAG=$1
TARGET_BRANCH=$2

INDEX=`expr index "$PRERELEASE_TAG" -`
RELEASE_TAG=${PRERELEASE_TAG:0:INDEX-1}

CURRENT_BRANCH="$(git symbolic-ref --short HEAD)"

STASH_OUTPUT=''

unstash_changes() {
	if [ "$STASH_OUTPUT" != "No local changes to save" ]; then
		POP_STASH="$(git stash pop)"
		if [ $? != 0 ]; then
			echo "ERROR:"
			echo "$POP_STASH"
			exit 9
		fi
	fi
}

restore_original_state()
{
	CLEAR_INDEX="$(git reset --hard HEAD)"
	if [ $? != 0 ]; then
		echo "ERROR:"
		echo "$CLEAR_INDEX"
	fi
	CHECKOUT_ORIGINAL_OUTPUT="$(git checkout -q $CURRENT_BRANCH)"
	if [ $? != 0 ]; then
		echo "ERROR:"
		echo "$CHECKOUT_ORIGINAL_OUTPUT"
		exit 8
	fi
	unstash_changes
}

run_command()
{
	echo $1
	output="$($1 2>&1)"
	if [ $? != 0 ]; then
		printf "ERROR: %s\n" "$output"
		return 1
	else
		printf "OUTPUT: %s\n" "$output"
		return 0
	fi
}

STASH_OUTPUT="$(git stash save)" || exit 1; 
run_command "git fetch -q --tags" || { unstash_changes && exit 2; }
run_command "git checkout -q $TARGET_BRANCH" || { unstash_changes && exit 3; }
run_command "git merge -q --ff-only origin/$TARGET_BRANCH" || { restore_original_state && exit 4; }
run_command "git merge -q -S --no-ff $PRERELEASE_TAG" || { restore_original_state && exit 5; }
run_command "git tag -s $RELEASE_TAG -m $RELEASE_TAG" || { restore_original_state && exit 6; }
run_command "git push -q origin $TARGET_BRANCH --tags" || { restore_original_state && exit 7; }

restore_original_state

exit 0
